{"name":"Bloomd","tagline":"A high performance C server for bloom filters","body":"Bloomd [![Build Status](https://travis-ci.org/armon/bloomd.png?branch=master)](https://travis-ci.org/armon/bloomd)\r\n=========\r\n\r\nBloomd is a high-performance C server which is used\r\nto expose bloom filters and operations over them to\r\nnetworked clients. It uses a simple ASCI protocol\r\nwhich is human readable, and similar to memcached.\r\n\r\nFeatures\r\n--------\r\n\r\n* Scalable non-blocking core allows for many connected\r\n  clients and concurrent operations\r\n* Implements scalable bloom filters, allowing dynamic filter sizes\r\n* Supports asynchronous flushes to disk for persistence\r\n* Supports non-disk backed bloom filters for high I/O\r\n* Automatically faults cold filters out of memory to save resources\r\n* Dead simple to start and administer\r\n* FAST, FAST, FAST\r\n\r\nInstall\r\n-------\r\n\r\nDownload and build from source::\r\n\r\n    $ git clone https://armon@github.com/armon/bloomd.git\r\n    $ cd bloomd\r\n    $ pip install SCons  # Uses the Scons build system, may not be necessary\r\n    $ scons\r\n    $ ./bloomd\r\n\r\nThis will generate some errors related to building the test code\r\nas it depends on libcheck. To build the test code successfully,\r\ndo the following::\r\n\r\n    $ cd deps/check-0.9.8/\r\n    $ ./configure\r\n    $ make\r\n    # make install\r\n    # ldconfig (necessary on some Linux distros)\r\n\r\nThen re-build bloomd. At this point, the test code should build\r\nsuccessfully.\r\n\r\nFor CentOS or RHEL users, the kind folks from Vortex RPM have made\r\na repo available with RPM's.\r\n\r\n* Repo: http://vortex-rpm.org/\r\n* Bloomd RPM spec: https://github.com/vortex-rpm/bloomd\r\n\r\nUsage\r\n-----\r\n\r\nBloomd can be configured using a file which is in INI format.\r\nHere is an example configuration file:\r\n\r\n::\r\n\r\n    # Settings for bloomd\r\n    [bloomd]\r\n    tcp_port = 8673\r\n    udp_port = 8674\r\n    data_dir = /mnt/bloomd\r\n    log_level = INFO\r\n    cold_interval = 3600\r\n    flush_interval = 60\r\n    initial_capacity = 100000\r\n    default_probability = 0.0001\r\n    workers = 2\r\n\r\n\r\nThen run bloomd, pointing it to that file::\r\n\r\n    bloomd -f /etc/bloomd.conf\r\n\r\nProtocol\r\n--------\r\n\r\nBy default, Bloomd will listen for TCP connections on port 8673.\r\nIt uses a simple ASCII protocol that is very similar to memcached.\r\n\r\nA command has the following syntax::\r\n\r\n    cmd [args][\\r]\\n\r\n\r\nWe start each line by specifying a command, providing optional arguments,\r\nand ending the line in a newline (carriage return is optional).\r\n\r\nThere are a total of 10 commands:\r\n\r\n* create - Create a new filter (a filter is a named bloom filter)\r\n* list - List all filters\r\n* drop - Drop a filters (Deletes from disk)\r\n* close - Closes a filter (Unmaps from memory, but still accessible)\r\n* clear - Clears a filter from the lists (Removes memory, left on disk)\r\n* check|c - Check if a key is in a filter\r\n* multi|m - Checks if a list of keys are in a filter\r\n* set|s - Set an item in a filter\r\n* bulk|b - Set many items in a filter at once\r\n* info - Gets info about a filter\r\n* flush - Flushes all filters or just a specified one\r\n\r\nFor the ``create`` command, the format is::\r\n\r\n    create filter_name [capacity=initial_capacity] [prob=max_prob] [in_memory=0|1]\r\n\r\nWhere ``filter_name`` is the name of the filter,\r\nand can contain the characters a-z, A-Z, 0-9, ., _.\r\nIf an initial capacity is provided the filter\r\nwill be created to store at least that many items in the initial filter.\r\nOtherwise the configured default value will be used.\r\nIf a maximum false positive probability is provided,\r\nthat will be used, otherwise the configured default is used.\r\nYou can optionally specify in_memory to force the filter to not be\r\npersisted to disk.\r\n\r\nAs an example::\r\n\r\n    create foobar capacity=1000000 prob=0.001\r\n\r\nThis will create a filter foobar that has a 1M initial capacity,\r\nand a 1/1000 probability of generating false positives. Valid responses\r\nare either \"Done\", \"Exists\", or \"Delete in progress\". The last response\r\noccurs if a filter of the same name was recently deleted, and bloomd\r\nhas not yet completed the delete operation. If so, a client should\r\nretry the create in a few seconds.\r\n\r\nThe ``list`` command takes no arguments, and returns information\r\nabout all the filters. Here is an example response::\r\n\r\n    START\r\n    foobar 0.001 1797211 1000000 0\r\n    END\r\n\r\nThis indicates a single filter named foobar, with a probability\r\nof 0.001 of false positives, a 1.79MB size, a current capacity of\r\n1M items, and 0 current items. The size and capacity automatically\r\nscale as more items are added.\r\n\r\nThe ``drop``, ``close`` and ``clear`` commands are like create, but only takes a filter name.\r\nIt can either return \"Done\" or \"Filter does not exist\". ``clear`` can also return \"Filter is not proxied. Close it first.\".\r\nThis means that the filter is still in-memory and not qualified for being cleared.\r\nThis can be resolved by first closing the filter.\r\n\r\nCheck and set look similar, they are either::\r\n\r\n    [check|set] filter_name key\r\n\r\nThe command must specify a filter and a key to use.\r\nThey will either return \"Yes\", \"No\" or \"Filter does not exist\".\r\n\r\n\r\nThe bulk and multi commands are similar to check/set but allows for many keys\r\nto be set or checked at once. Keys must be separated by a space::\r\n\r\n    [multi|bulk] filter_name key1 [key_2 [key_3 [key_N]]]\r\n\r\nThe check, multi, set and bulk commands can also be called by their aliasses\r\nc, m, s and b respectively.\r\n\r\nThe ``info`` command takes a filter name, and returns\r\ninformation about the filter. Here is an example output::\r\n\r\n    START\r\n    capacity 1000000\r\n    checks 0\r\n    check_hits 0\r\n    check_misses 0\r\n    page_ins 0\r\n    page_outs 0\r\n    probability 0.001\r\n    sets 0\r\n    set_hits 0\r\n    set_misses 0\r\n    size 0\r\n    storage 1797211\r\n    END\r\n\r\nThe command may also return \"Filter does not exist\" if the filter does\r\nnot exist.\r\n\r\nThe ``flush`` command may be called without any arguments, which\r\ncauses all filters to be flushed. If a filter name is provided\r\nthen that filter will be flushed. This will either return \"Done\" or\r\n\"Filter does not exist\".\r\n\r\nExample\r\n----------\r\n\r\nHere is an example of a client flow, assuming bloomd is\r\nrunning on the default port using just telnet::\r\n\r\n    $ telnet localhost 8673\r\n    > list\r\n    START\r\n    END\r\n\r\n    > create foobar\r\n    Done\r\n\r\n    > check foobar zipzab\r\n    No\r\n\r\n    > set foobar zipzab\r\n    Yes\r\n\r\n    > check foobar zipzab\r\n    Yes\r\n\r\n    > multi foobar zipzab blah boo\r\n    Yes No No\r\n\r\n    > bulk foobar zipzab blah boo\r\n    No Yes Yes\r\n\r\n    > multi foobar zipzab blah boo\r\n    Yes Yes Yes\r\n\r\n    > list\r\n    START\r\n    foobar 0.000100 300046 100000 3\r\n    END\r\n\r\n    > drop foobar\r\n    Done\r\n\r\n    > list\r\n    START\r\n    END\r\n\r\n\r\nClients\r\n----------\r\n\r\nHere is a list of known client implementations:\r\n\r\n* Python : https://github.com/kiip/bloom-python-driver\r\n* Ruby : https://github.com/SponsorPay/bloomrb\r\n* Erlang : https://github.com/armon/erl-bloomd\r\n* Go : https://github.com/geetarista/go-bloomd\r\n\r\n\r\nHere is a list of \"best-practices\" for client implementations:\r\n\r\n* Maintain a set of open connections to the server to minimize connection time\r\n* Make use of the bulk operations when possible, as they are more efficient.\r\n* For long keys, it is better to do a client-side hash (SHA1 at least), and send\r\n  the hash as the key to minimize network traffic.\r\n\r\nPerformance\r\n-----------\r\n\r\nAlthough extensive performance evaluations have not been done,\r\ncasual testing on a 2012 MBP with pure set/check operations\r\nallows for a throughput of at least 600K ops/sec. On Linux,\r\nresponse times can be as low as 1.5 Î¼s.\r\n\r\nBloomd also supports multi-core systems for scalability, so\r\nit is important to tune it for the given work load. The number\r\nof worker threads can be configured either in the configuration\r\nfile, or by providing a `-w` flag. This should be set to at most\r\n2 * CPU count. By default, only a single worker is used.\r\n\r\nReferences\r\n-----------\r\n\r\nHere are some related works which we make use of:\r\n\r\n* Space/Time Trade-offs in Hash Coding with Allowable Errors (Bloom): http://www.lsi.upc.edu/~diaz/p422-bloom.pdf\r\n* Scalable Bloom Filters (Almeida et. al): http://gsd.di.uminho.pt/members/cbm/ps/dbloom.pdf\r\n* Less Hashing, Same Performance: Building a Better Bloom Filter (Kirsch and Mitzenmacher): http://www.eecs.harvard.edu/~kirsch/pubs/bbbf/esa06.pdf\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}